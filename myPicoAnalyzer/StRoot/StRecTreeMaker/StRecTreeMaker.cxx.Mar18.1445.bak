//Modified from StMiniMcMaker.cxx
///////////////////////////////////////////////////////////
#include "StMuDSTMaker/COMMON/StMuDstMaker.h"
#include "StMuDSTMaker/COMMON/StMuEvent.h"
#include "StMuDSTMaker/COMMON/StMuDst.h"
#include "StMuDSTMaker/COMMON/StMuTrack.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcTrack.h"

#include "StRecTreeMaker.h"
#include "StEventTypes.h"
#include "StEvent.h"
#include "StParticleTable.hh"
#include "StParticleDefinition.hh"
#include "TNtuple.h"
#include "TFile.h"
#include "TTree.h"
#include "TBranch.h"
#include "TMath.h"

#include "StMcEventMaker/StMcEventMaker.h"
#include "StMcEventTypes.hh"
#include "StMcEvent.hh"
#include "StMcEvent/StMcTrack.hh"
#include "StMcEvent/StMcTpcHitCollection.hh"
#include "StMcEvent/StMcTpcHit.hh"
#include "StMcEvent/StMcEmcHitCollection.hh"
#include "StMcEvent/StMcCalorimeterHit.hh"
#include "StMcEvent/StMcTofHitCollection.hh"
#include "StMcEvent/StMcTofHit.hh"
#include "StEvent/StTpcHitCollection.h"
#include "StEvent/StTpcHit.h"
#include "StEvent/StTrackPidTraits.h"
#include "StEvent/StDedxPidTraits.h"
#include "StEventUtilities/StuRefMult.hh"
#include "StBFChain.h"
#include "StMessMgr.h"

#include "StChain.h"
#include "St_DataSet.h"
#include "St_DataSetIter.h"
#include "StEventTypes.h"
#include "StTpcDedxPidAlgorithm.h"
#include "StParticleDefinition.hh"
#include "StPhysicalHelix.hh"
/*
#include "StStrangeMuDstMaker/StStrangeMuDstMaker.h"
#include "StStrangeMuDstMaker/StStrangeEvMuDst.hh"
#include "StStrangeMuDstMaker/StV0MuDst.hh"
#include "StStrangeMuDstMaker/StV0Mc.hh"
#include "StStrangeMuDstMaker/StXiMuDst.hh"
#include "StStrangeMuDstMaker/StXiMc.hh"
#include "StStrangeMuDstMaker/StKinkMuDst.hh"
#include "StStrangeMuDstMaker/StKinkMc.hh"
*/

#include "RecTree.h"

ClassImp(StRecTreeMaker)	// this a macro, no ";" here

StRecTreeMaker::StRecTreeMaker(StMuDstMaker* maker, const Char_t *outname="") : 
	mTupFile(0),
	trackTree(0)
{
	mMuDstMaker = maker;
	outName = outname;

	return;
}

StRecTreeMaker::~StRecTreeMaker() { return; }

Int_t StRecTreeMaker::Init()
{
	outName.ReplaceAll("root","rectree.root");
	mTupFile = new TFile(outName, "RECREATE");
	mTupFile->SetCompressionLevel(9);
	trackTree= new TTree("mTrackEvent","trackTree");
	trackTree->SetAutoSave(1000000);

	cout << "Initialize the recotree ... " << endl;

	trackTree->Branch("mIEvt",&mTrackEvent.mIEvt,"mIEvt/I");
	trackTree->Branch("OriginMult",&mTrackEvent.OriginMult,"OriginMult/I");
	trackTree->Branch("McMult",&mTrackEvent.McMult,"McMult/I");
	trackTree->Branch("mRcVertexX",&mTrackEvent.mRcVertexX,"mRcVertexX/F");
	trackTree->Branch("mRcVertexY",&mTrackEvent.mRcVertexY,"mRcVertexY/F");
	trackTree->Branch("mRcVertexZ",&mTrackEvent.mRcVertexZ,"mRcVertexZ/F");
	trackTree->Branch("mMcVertexX",&mTrackEvent.mMcVertexX,"mMcVertexX/F");
	trackTree->Branch("mMcVertexY",&mTrackEvent.mMcVertexY,"mMcVertexY/F");
	trackTree->Branch("mMcVertexZ",&mTrackEvent.mMcVertexZ,"mMcVertexZ/F");
	trackTree->Branch("MagField",&mTrackEvent.MagField,"MagField/F");

	trackTree->Branch("mNMcTrk",&mTrackEvent.mNMcTrk,"mNMcTrk/I");
	trackTree->Branch("mNRcTrk",&mTrackEvent.mNRcTrk,"mNRcTrk/I");
//*************************************************************************************************
	trackTree->Branch("nv0",&mTrackEvent.nv0,"nv0/I");
//	trackTree->Branch("ndau1",&mTrackEvent.ndau1,"ndau1/I");
	trackTree->Branch("ndau2",&mTrackEvent.ndau2,"ndau2/I");
	trackTree->Branch("ndau3",&mTrackEvent.ndau3,"ndau3/I");
	
	trackTree->Branch("v0mass",mTrackEvent.v0mass,"v0mass[nv0]/F");
	trackTree->Branch("v0pt",mTrackEvent.v0pt,"v0pt[nv0]/F");
	trackTree->Branch("v0rapidity",mTrackEvent.v0rapidity,"v0rapidity[nv0]/F");
	trackTree->Branch("v0eta",mTrackEvent.v0eta,"v0eta[nv0]/F");
	trackTree->Branch("v0x",mTrackEvent.v0x,"v0x[nv0]/F");
	trackTree->Branch("v0y",mTrackEvent.v0y,"v0y[nv0]/F");
	trackTree->Branch("v0z",mTrackEvent.v0z,"v0z[nv0]/F");
	trackTree->Branch("v0px",mTrackEvent.v0px,"v0px[nv0]/F");
	trackTree->Branch("v0py",mTrackEvent.v0py,"v0py[nv0]/F");
	trackTree->Branch("v0pz",mTrackEvent.v0pz,"v0pz[nv0]/F");
	trackTree->Branch("v0declen",mTrackEvent.v0declen,"v0declen[nv0]/F");
	trackTree->Branch("v0dca",mTrackEvent.v0dca,"v0dca[nv0]/F");
//	trackTree->Branch("dca1to2",mTrackEvent.dca1to2,"dca1to2[nv0]/F");
//	trackTree->Branch("dca1to3",mTrackEvent.dca1to3,"dca1to3[nv0]/F");
	trackTree->Branch("dca2to3",mTrackEvent.dca2to3,"dca2to3[nv0]/F");
//	trackTree->Branch("dca1toxv0123",mTrackEvent.dca1toxv0123,"dca1toxv0123[nv0]/F");
//	trackTree->Branch("dca2toxv0123",mTrackEvent.dca2toxv0123,"dca2toxv0123[nv0]/F");
//	trackTree->Branch("dca3toxv0123",mTrackEvent.dca3toxv0123,"dca3toxv0123[nv0]/F");
//*****
//	trackTree->Branch("dca1toxv012",mTrackEvent.dca1toxv012,"dca1toxv012[nv0]/F");
//	trackTree->Branch("dca2toxv012",mTrackEvent.dca2toxv012,"dca2toxv012[nv0]/F");
	trackTree->Branch("dca2toxv023",mTrackEvent.dca2toxv023,"dca2toxv023[nv0]/F");
	trackTree->Branch("dca3toxv023",mTrackEvent.dca3toxv023,"dca3toxv023[nv0]/F");
//	trackTree->Branch("dca1toxv013",mTrackEvent.dca1toxv013,"dca1toxv013[nv0]/F");
//	trackTree->Branch("dca3toxv013",mTrackEvent.dca3toxv013,"dca3toxv013[nv0]/F");
//	trackTree->Branch("xv012toPV",mTrackEvent.xv012toPV,"xv012toPV[nv0]/F");
	trackTree->Branch("xv023toPV",mTrackEvent.xv023toPV,"xv023toPV[nv0]/F");
//	trackTree->Branch("xv013toPV",mTrackEvent.xv013toPV,"xv013toPV[nv0]/F");
//	trackTree->Branch("dcaxv012toPV",mTrackEvent.dcaxv012toPV,"dcaxv012toPV[nv0]/F");
	trackTree->Branch("dcaxv023toPV",mTrackEvent.dcaxv023toPV,"dcaxv023toPV[nv0]/F");
//	trackTree->Branch("dcaxv013toPV",mTrackEvent.dcaxv013toPV,"dcaxv013toPV[nv0]/F");
/*
	trackTree->Branch("dau1id",mTrackEvent.dau1id,"dau1id[nv0]/I");
	trackTree->Branch("dau1dca",mTrackEvent.dau1dca,"dau1dca[nv0]/F");
	trackTree->Branch("dau1nhits",mTrackEvent.dau1nhits,"dau1nhits[nv0]/I");
	trackTree->Branch("dau1nhitsfit",mTrackEvent.dau1nhitsfit,"dau1nhitsfit[nv0]/I");
	trackTree->Branch("dau1nhitsposs",mTrackEvent.dau1nhitsposs,"dau1nhitsposs[nv0]/I");
	trackTree->Branch("dau1nhitsdedx",mTrackEvent.dau1nhitsdedx,"dau1nhitsdedx[nv0]/I");
	trackTree->Branch("dau1eta",mTrackEvent.dau1eta,"dau1eta[nv0]/F");
	trackTree->Branch("dau1dedx",mTrackEvent.dau1dedx,"dau1dedx[nv0]/F");
	trackTree->Branch("dau1Z",mTrackEvent.dau1Z,"dau1Z[nv0]/F");
	trackTree->Branch("dau1nsigma",mTrackEvent.dau1nsigma,"dau1nsigma[nv0]/F");
	trackTree->Branch("dau1pt",mTrackEvent.dau1pt,"dau1pt[nv0]/F");
	trackTree->Branch("dau1px",mTrackEvent.dau1px,"dau1px[nv0]/F");
	trackTree->Branch("dau1py",mTrackEvent.dau1py,"dau1py[nv0]/F");
	trackTree->Branch("dau1pz",mTrackEvent.dau1pz,"dau1pz[nv0]/F");
	trackTree->Branch("dau1tpc",mTrackEvent.dau1tpc,"dau1tpc[nv0]/I");
	trackTree->Branch("dau1mass",mTrackEvent.dau1mass,"dau1mass[nv0]/F"); // xuyifei_Feb13
	trackTree->Branch("dau1beta",mTrackEvent.dau1beta,"dau1beta[nv0]/F"); // xuyifei_Feb13
*/
	trackTree->Branch("dau2id",mTrackEvent.dau2id,"dau2id[nv0]/I");
	trackTree->Branch("dau2dca",mTrackEvent.dau2dca,"dau2dca[nv0]/F");
	trackTree->Branch("dau2nhits",mTrackEvent.dau2nhits,"dau2nhits[nv0]/I");
	trackTree->Branch("dau2nhitsfit",mTrackEvent.dau2nhitsfit,"dau2nhitsfit[nv0]/I");
	trackTree->Branch("dau2nhitsposs",mTrackEvent.dau2nhitsposs,"dau2nhitsposs[nv0]/I");
	trackTree->Branch("dau2nhitsdedx",mTrackEvent.dau2nhitsdedx,"dau2nhitsdedx[nv0]/I");
	trackTree->Branch("dau2eta",mTrackEvent.dau2eta,"dau2eta[nv0]/F");
	trackTree->Branch("dau2dedx",mTrackEvent.dau2dedx,"dau2dedx[nv0]/F");
	trackTree->Branch("dau2nsigma",mTrackEvent.dau2nsigma,"dau2nsigma[nv0]/F");
	trackTree->Branch("dau2pt",mTrackEvent.dau2pt,"dau2pt[nv0]/F");
	trackTree->Branch("dau2px",mTrackEvent.dau2px,"dau2px[nv0]/F");
	trackTree->Branch("dau2py",mTrackEvent.dau2py,"dau2py[nv0]/F");
	trackTree->Branch("dau2pz",mTrackEvent.dau2pz,"dau2pz[nv0]/F");
//	trackTree->Branch("dau2tpc",mTrackEvent.dau2tpc,"dau2tpc[nv0]/I");
//	trackTree->Branch("dau2mass",mTrackEvent.dau2mass,"dau2mass[nv0]/F"); // xuyifei_Feb13
//	trackTree->Branch("dau2beta",mTrackEvent.dau2beta,"dau2beta[nv0]/F"); // xuyifei_Feb13

	trackTree->Branch("dau3id",mTrackEvent.dau3id,"dau3id[nv0]/I");
	trackTree->Branch("dau3dca",mTrackEvent.dau3dca,"dau3dca[nv0]/F");
	trackTree->Branch("dau3nhits",mTrackEvent.dau3nhits,"dau3nhits[nv0]/I");
	trackTree->Branch("dau3nhitsfit",mTrackEvent.dau3nhitsfit,"dau3nhitsfit[nv0]/I");
	trackTree->Branch("dau3nhitsposs",mTrackEvent.dau3nhitsposs,"dau3nhitsposs[nv0]/I");
	trackTree->Branch("dau3nhitsdedx",mTrackEvent.dau3nhitsdedx,"dau3nhitsdedx[nv0]/I");
	trackTree->Branch("dau3eta",mTrackEvent.dau3eta,"dau3eta[nv0]/F");
	trackTree->Branch("dau3dedx",mTrackEvent.dau3dedx,"dau3dedx[nv0]/F");
	trackTree->Branch("dau3nsigma",mTrackEvent.dau3nsigma,"dau3nsigma[nv0]/F");
	trackTree->Branch("dau3pt",mTrackEvent.dau3pt,"dau3pt[nv0]/F");
	trackTree->Branch("dau3px",mTrackEvent.dau3px,"dau3px[nv0]/F");
	trackTree->Branch("dau3py",mTrackEvent.dau3py,"dau3py[nv0]/F");
	trackTree->Branch("dau3pz",mTrackEvent.dau3pz,"dau3pz[nv0]/F");
//	trackTree->Branch("dau3tpc",mTrackEvent.dau3tpc,"dau3tpc[nv0]/I");
//	trackTree->Branch("dau3mass",mTrackEvent.dau3mass,"dau3mass[nv0]/F"); // xuyifei_Feb13
//	trackTree->Branch("dau3beta",mTrackEvent.dau3beta,"dau3beta[nv0]/F"); // xuyifei_Feb13

//*************************************************************************************************
	mDauVec1.clear();// StMuTrack*
	mDauVec2.clear();
	mDauVec3.clear();

//	mDauDcaVec1.clear();// Double
//	mDauDcaVec2.clear();
//	mDauDcaVec3.clear();
//	mDauMass1.clear();
//	mDauMass2.clear();
//	mDauMass3.clear();
//	mDauBeta1.clear();
//	mDauBeta2.clear();
//	mDauBeta3.clear();
//*************************************************************************************************

	return StMaker::Init();
}

void StRecTreeMaker::Clear(Option_t *opt)
{
	StMaker::Clear();
}

Int_t StRecTreeMaker::Finish()
{

	mTupFile->Write();
	mTupFile->Close();

	return kStOK;
}

Int_t StRecTreeMaker::Make()
{
//	StMuDst*	muDst	= mMuDstMaker->muDst();
	StMuEvent*	muEvent = mMuDstMaker->muDst()->event();
	if(!muEvent ) return kStOK;

//*******************************************************************
	double mMassProton = 0.93827;
	double mMassPion = 0.13957;
	double mMassLambda = 1.11568;
//*******************************************************************
//event level
	tb_mIEvt = muEvent->eventId();
	tb_MagField = mMuDstMaker->muDst()->event()->magneticField()/10.;

	double magn = muEvent->magneticField();

	StThreeVectorF pv;

//*******************************************************************
	TClonesArray *PrimaryVertices = mMuDstMaker->muDst()->primaryVertices();
	Int_t NoPrimaryVertices = PrimaryVertices->GetEntriesFast();

	TClonesArray *GlobalTracks = mMuDstMaker->muDst()->array(muGlobal);
	Int_t NoGlobalTracks = GlobalTracks->GetEntriesFast(); 

	TClonesArray *MuMcVertices = mMuDstMaker->muDst()->mcArray(0);
	Int_t NoMuMcVertices = MuMcVertices->GetEntriesFast();

	TClonesArray *MuMcTracks = mMuDstMaker->muDst()->mcArray(1);
	Int_t NoMuMcTracks = MuMcTracks->GetEntriesFast(); 

	if (! NoMuMcVertices || ! NoMuMcTracks)
	{
		cout << "Event has no MC information ==> skip it" << endl;
		return kStOK;
	}

	Int_t nVtx = 0;
	if(NoPrimaryVertices!=(int)mMuDstMaker->muDst()->numberOfPrimaryVertices())
	{
		cout << "No. of Primary Vertices inconsistent! " << endl;// return kStOk;
	}
	cout << "Found " << NoPrimaryVertices << " Primary Vertices ! " << endl;
//*******************************************************************
	for(int i = 0; i < (int)(mMuDstMaker->muDst()->numberOfPrimaryVertices()); i++)
	{
		StMuPrimaryVertex *pVtx = mMuDstMaker->muDst()->primaryVertex(i);
		if(!pVtx)
		{
			cout << "no vertex pointer! " << endl;
			continue;
		}
		if(!pVtx->idTruth() || pVtx->idTruth()<0 || pVtx->idTruth()>NoMuMcVertices)
		{
			cout << "Illegal idTruth " << pVtx->idTruth() << " The vertex is ignored" << endl;
			continue;
		}
		StMuMcVertex *mcVertex = (StMuMcVertex *) MuMcVertices->UncheckedAt(pVtx->idTruth()-1);
		if(mcVertex->Id() != pVtx->idTruth())
		{
			cout << "Mismatched idTruth " << pVtx->idTruth() << " and mcVertex Id " <<mcVertex->Id() << " The vertex is ignored" <<endl;
			continue;
		}
		StThreeVectorF mVertexPosition = pVtx->position();
		tb_mRcVertexX = mVertexPosition.x(); 
		tb_mRcVertexY = mVertexPosition.y(); 
		tb_mRcVertexZ = mVertexPosition.z();
		tb_OriginMult = mMuDstMaker->muDst()->event()->refMult();
		tb_mMcVertexX = mcVertex->XyzV().x(); 
		tb_mMcVertexY = mcVertex->XyzV().y(); 
		tb_mMcVertexZ = mcVertex->XyzV().z();
		tb_McMult = mcVertex->NoDaughters();
		pv.setX(mVertexPosition.x());
		pv.setY(mVertexPosition.y());
		pv.setZ(mVertexPosition.z());

		nVtx++; break;
	}

	if (nVtx<=0)
	{
		cout << "Event has no valid Vertex info. ==> skip it" << endl;
		tb_mRcVertexX = -999.; 
		tb_mRcVertexY = -999.; 
		tb_mRcVertexZ = -999.;
		pv.setX(-999);
		pv.setY(-999);
		pv.setZ(-999);
		tb_OriginMult = mMuDstMaker->muDst()->event()->refMult();
		StMuMcVertex *mcVertex = (StMuMcVertex *) MuMcVertices->UncheckedAt(0);
		if(!mcVertex)
		{
			tb_mMcVertexX = -999.; 
			tb_mMcVertexY = -999.; 
			tb_mMcVertexZ = -999.;
			tb_McMult = 0;
		}
		else
		{
			tb_mMcVertexX = mcVertex->XyzV().x(); 
			tb_mMcVertexY = mcVertex->XyzV().y(); 
			tb_mMcVertexZ = mcVertex->XyzV().z();
			tb_McMult = mcVertex->NoDaughters();
		}
		return kStOK;
	}
	if(pv.x() <=0 || pv.y() <=0 || pv.z()<=0) return 0;

	cout << "Event variables filled" << endl;
	//track level

	Int_t imc = 0;
	for(Int_t m = 0; m < NoMuMcTracks; m++)
	{
		StMuMcTrack *mcTrack = (StMuMcTrack *) MuMcTracks->UncheckedAt(m);
		if(! mcTrack) continue;
		Int_t IdVx = mcTrack->IdVx();
	
		imc++;
	}
	tb_mNMcTrk = imc;

	int irc = 0;
	if(NoGlobalTracks!=(int)mMuDstMaker->muDst()->numberOfGlobalTracks())
	{
		cout << "No. of global tracks inconsistent! " << endl;
	}
	for(int i = 0; i<(int)mMuDstMaker->muDst()->numberOfGlobalTracks(); i++)// loop for a track
	{
		StMuTrack *gTrack = mMuDstMaker->muDst()->globalTracks(i);

		if(!gTrack) continue;
		if(gTrack->flag()<=0 || gTrack->flag()>=1000) continue;
		int nHitsFit = gTrack->nHitsFit(); // remove kTpcId;
//		if(nHitsFit<5) continue;
		float ratio = (1.0*nHitsFit)/(1.0*gTrack->nHitsPoss()); //remove kTpcId;
//		if(ratio<0.1) continue;

		if(gTrack->idTruth() <= 0 || gTrack->idTruth() > NoMuMcTracks)
		{
			cout << "Illegal idTruth " << gTrack->idTruth() << " The track is ignored" << endl;
			continue;
		}
		StMuMcTrack *mcTrack = (StMuMcTrack *) MuMcTracks->UncheckedAt(gTrack->idTruth()-1);
		if (mcTrack->Id() != gTrack->idTruth())
		{
			cout << "Mismatched idTruth " << gTrack->idTruth() << " and mcTrack Id " <<mcTrack->Id() << " The track is ignored" <<endl;
			continue;
		}
		else
		{
			;
		}
		
//*************************************************************************************************
		int track_id = 0;
		int track_charge = 0;
		int track_nhits = 0;
		int track_nhitsfit = 0;
		int track_nhitsposs = 0;
		int track_nhitsdedx = 0;
		double track_eta = 0;
		double track_dedx = 0;
		double track_nsigma_proton = 0;
		double track_nsigma_pion = 0;
		double track_pt = 0;
		double track_px = 0;
		double track_py = 0;
		double track_pz = 0;
//		int track_tpc = 0;
//		double track_mass = 0;
//		double track_beta = 0;

		track_id = gTrack->id();
		track_charge = gTrack->charge();
		track_nhits = gTrack->nHits();
		track_nhitsfit = gTrack->nHitsFit();
		track_nhitsposs = gTrack->nHitsPoss();
		track_nhitsdedx = gTrack->nHitsDedx();
		track_eta = gTrack->eta();
		track_dedx = gTrack->dEdx();
		track_pt = gTrack->pt();
		track_px = gTrack->p().x();
		track_py = gTrack->p().y();
		track_pz = gTrack->p().z();
		track_nsigma_proton = gTrack->nSigmaProton();
		track_nsigma_pion = gTrack->nSigmaPion();

		if(track_nhitsfit < 15) continue;
		if(track_nhitsdedx< 15) continue;
		if(fabs(track_charge) != 1) continue;
		if(fabs(track_eta) > 1.0) continue;
		if(double(track_nhitsfit)/double(track_nhitsposs)<0.52) continue;
		if(track_pt<0.15) continue;
//*************************************************************************************************

		StMuTrack *pTrack = const_cast<StMuTrack *>(gTrack->primaryTrack());
	
		StPhysicalHelixD ghelix = gTrack->helix();
		StPhysicalHelixD helix = gTrack->outerHelix();

		irc++;
//*************************************************************************************************
		if(track_nsigma_proton >= -2 && track_nsigma_proton <= 2)
		{
			mDauVec2.push_back(gTrack);
		}
		if(track_nsigma_pion >= -2 && track_nsigma_pion <= 2)
		{
			mDauVec3.push_back(gTrack);
		}
//*************************************************************************************************
	}
//*************************************************************************************************
	tb_mNRcTrk=irc;

	mTrackEvent.mIEvt = tb_mIEvt;
	mTrackEvent.OriginMult = tb_OriginMult;
	mTrackEvent.McMult = tb_McMult;
	mTrackEvent.mRcVertexX = tb_mRcVertexX;
	mTrackEvent.mRcVertexY = tb_mRcVertexY;
	mTrackEvent.mRcVertexZ = tb_mRcVertexZ;
	mTrackEvent.mMcVertexX = tb_mMcVertexX;
	mTrackEvent.mMcVertexY = tb_mMcVertexY;
	mTrackEvent.mMcVertexZ = tb_mMcVertexZ;
	mTrackEvent.MagField = tb_MagField;
		
	mTrackEvent.mNMcTrk = tb_mNMcTrk;
	mTrackEvent.mNRcTrk = tb_mNRcTrk;

	int nv0=0;
	tb_nv0=0;
//	tb_ndau1=0;
	tb_ndau2= mDauVec2.size();
	tb_ndau3= mDauVec3.size();

	mTrackEvent.nv0 = tb_nv0;
//	mTrackEvent.ndau1 = tb_ndau1;
	mTrackEvent.ndau2 = tb_ndau2;
	mTrackEvent.ndau3 = tb_ndau3;

	for(unsigned int j = 0; j < mDauVec2.size(); j++)
	{
		StMuTrack * track2 = mDauVec2[j];
		StPhysicalHelixD helix2 = track2->helix();

		for(unsigned int k = 0; k < mDauVec3.size(); k++)
		{
			StMuTrack * track3 = mDauVec3[k];
			StPhysicalHelixD helix3 = track3->helix();
			if(track2->id() == track3->id()) continue;

			double dca2_pathlength = helix2.pathLength(pv);
			double dca2 = (helix2.at(dca2_pathlength)).mag();
			double dca3_pathlength = helix3.pathLength(pv);
			double dca3 = (helix3.at(dca3_pathlength)).mag();
			
			StThreeVectorF xv023;
			StThreeVectorF pv023;

			StThreeVectorF ox2,ox3;
			StThreeVectorF op2,op3;

			pair<double,double> tmps = helix2.pathLengths(helix3);
			ox2 = helix2.at(tmps.first);
			ox3 = helix3.at(tmps.second);
			op2 = helix2.momentumAt(tmps.first,magn*kilogauss);
			op3 = helix3.momentumAt(tmps.second,magn*kilogauss);

			tb_dca2to3 = (ox2-ox3).mag();
			xv023 = (ox2 + ox3)/2.;
			pv023 = (op2 + op3);

			double pathdau2 = helix2.pathLength(xv023);
			double pathdau3 = helix3.pathLength(xv023);
			StThreeVectorF oox2 = helix2.at(pathdau2);
			StThreeVectorF oox3 = helix3.at(pathdau3);
			tb_dca2toxv023 = (oox2 - xv023).mag();
			tb_dca3toxv023 = (oox3 - xv023).mag();

			tb_xv023toPV = (xv023 - pv).mag();

			double par1 = fabs( (pv.y()-xv023.y())*pv023.z() - (pv.z()-xv023.z())*pv023.y() );
			double par2 = fabs( (pv.z()-xv023.z())*pv023.x() - (pv.x()-xv023.x())*pv023.z() );
			double par3 = fabs( (pv.x()-xv023.x())*pv023.y() - (pv.y()-xv023.y())*pv023.x() );
			double par4 = sqrt(par1*par1 + par2*par2 + par3*par3);
			double par5 = sqrt(pv023.x()*pv023.x() + pv023.y()*pv023.y() + pv023.z()*pv023.z());
			double tb_dcaxv023toPV = par4 / par5;

			// get all branch value of v0 xuyifei last 22:15
			if(dca2 > 1.0) continue;
			if(dca3 > 1.0) continue;
			if(tb_dca2to3 > 1.0) continue;
			
			double oe2 = sqrt(mMassProton*mMassProton + op2.mag2());
			double oe3 = sqrt(mMassPion*mMassPion + op3.mag2());
			tb_v0mass = sqrt(mMassProton*mMassProton + mMassPion*mMassPion + 2*oe2*oe3 - 2*op2.dot(op3));
			tb_v0x = xv023.x();
			tb_v0y = xv023.y();
			tb_v0z = xv023.z();
			tb_v0pt= pv023.perp();
			tb_v0px= pv023.x();
			tb_v0py= pv023.y();
			tb_v0pz= pv023.z();
			tb_v0declen = tb_xv023toPV;
			tb_v0dca = tb_dcaxv023toPV;
			tb_v0eta = 0.5*( (pv023.mag()+pv023.z())/(pv023.mag()-pv023.z()) );

			double v0energy = sqrt( mMassLambda*mMassLambda + pv023.mag2() );
			tb_v0rapidity = 0.5*( (v0energy + pv023.z())/(v0energy - pv023.z()) );

			tb_dau2id = track2->id();
			tb_dau2dca= dca2;
			tb_dau2nhits = track2->nHits();
			tb_dau2nhitsfit = track2->nHitsFit();
			tb_dau2nhitsposs = track2->nHitsPoss();
			tb_dau2nhitsdedx = track2->nHitsDedx();
			tb_dau2eta = track2->eta();
			tb_dau2dedx = track2->dEdx();
			tb_dau2nsigma= track2->nSigmaProton();
			tb_dau2pt = op2.perp();
			tb_dau2px = op2.x();
			tb_dau2py = op2.y();
			tb_dau2pz = op2.z();

			tb_dau3id = track3->id();
			tb_dau3dca= dca3;
			tb_dau3nhits = track3->nHits();
			tb_dau3nhitsfit = track3->nHitsFit();
			tb_dau3nhitsposs = track3->nHitsPoss();
			tb_dau3nhitsdedx = track3->nHitsDedx();
			tb_dau3eta = track3->eta();
			tb_dau3dedx = track3->dEdx();
			tb_dau3nsigma= track3->nSigmaPion();
			tb_dau3pt = op3.perp();
			tb_dau3px = op3.x();
			tb_dau3py = op3.y();
			tb_dau3pz = op3.z();
//*************************************************************************************************
			mTrackEvent.v0mass[nv0] = tb_v0mass;
			mTrackEvent.v0pt[nv0] = tb_v0pt;
			mTrackEvent.v0rapidity[nv0] = tb_v0rapidity;
			mTrackEvent.v0eta[nv0] = tb_v0eta;
			mTrackEvent.v0x[nv0] = tb_v0x;
			mTrackEvent.v0y[nv0] = tb_v0y;
			mTrackEvent.v0z[nv0] = tb_v0z;
			mTrackEvent.v0px[nv0] = tb_v0px;
			mTrackEvent.v0py[nv0] = tb_v0py;
			mTrackEvent.v0pz[nv0] = tb_v0pz;
			mTrackEvent.v0declen[nv0] = tb_v0declen;
			mTrackEvent.v0dca[nv0] = tb_v0dca;
		//	mTrackEvent.dca1to2[nv0] = tb_dca1to2;
		//	mTrackEvent.dca1to3[nv0] = tb_dca1to3;
			mTrackEvent.dca2to3[nv0] = tb_dca2to3;
		//	mTrackEvent.dca1toxv0123[nv0] = tb_dca1toxv0123;
		//	mTrackEvent.dca2toxv0123[nv0] = tb_dca2toxv0123;
		//	mTrackEvent.dca3toxv0123[nv0] = tb_dca3toxv0123;
		
		//	mTrackEvent.dca1toxv012[nv0] = tb_dca1toxv012;
		//	mTrackEvent.dca2toxv012[nv0] = tb_dca2toxv012;
			mTrackEvent.dca2toxv023[nv0] = tb_dca2toxv023;
			mTrackEvent.dca3toxv023[nv0] = tb_dca3toxv023;
		//	mTrackEvent.dca1toxv013[nv0] = tb_dca1toxv013;
		//	mTrackEvent.dca3toxv013[nv0] = tb_dca3toxv013;
		//	mTrackEvent.xv012toPV[nv0] = tb_xv012toPV;
			mTrackEvent.xv023toPV[nv0] = tb_xv023toPV;
		//	mTrackEvent.xv013toPV[nv0] = tb_xv013toPV;
		//	mTrackEvent.dcaxv012toPV[nv0] = tb_dcaxv012toPV;
			mTrackEvent.dcaxv023toPV[nv0] = tb_dcaxv023toPV;
		//	mTrackEvent.dcaxv013toPV[nv0] = tb_dcaxv013toPV;
		/*
			mTrackEvent.dau1id[nv0] = tb_dau1id;
			mTrackEvent.dau1dca[nv0] = tb_dau1dca;
			mTrackEvent.dau1nhits[nv0] = tb_dau1nhits;
			mTrackEvent.dau1nhitsfit[nv0] = tb_dau1nhitsfit;
			mTrackEvent.dau1nhitsposs[nv0] = tb_dau1nhitsposs;
			mTrackEvent.dau1nhitsdedx[nv0] = tb_dau1nhitsdedx;
			mTrackEvent.dau1eta[nv0] = tb_dau1eta;
			mTrackEvent.dau1dedx[nv0] = tb_dau1dedx;
			mTrackEvent.dau1Z[nv0] = tb_dau1Z;
			mTrackEvent.dau1nsigma[nv0] = tb_dau1nsigma;
			mTrackEvent.dau1pt[nv0] = tb_dau1pt;
			mTrackEvent.dau1px[nv0] = tb_dau1px;
			mTrackEvent.dau1py[nv0] = tb_dau1py;
			mTrackEvent.dau1pz[nv0] = tb_dau1pz;
			mTrackEvent.dau1tpc[nv0] = tb_dau1tpc;
			mTrackEvent.dau1mass[nv0] = tb_dau1mass;
			mTrackEvent.dau1beta[nv0] = tb_dau1beta;
		*/
			mTrackEvent.dau2id[nv0] = tb_dau2id;
			mTrackEvent.dau2dca[nv0] = tb_dau2dca;
			mTrackEvent.dau2nhits[nv0] = tb_dau2nhits;
			mTrackEvent.dau2nhitsfit[nv0] = tb_dau2nhitsfit;
			mTrackEvent.dau2nhitsposs[nv0] = tb_dau2nhitsposs;
			mTrackEvent.dau2nhitsdedx[nv0] = tb_dau2nhitsdedx;
			mTrackEvent.dau2eta[nv0] = tb_dau2eta;
			mTrackEvent.dau2dedx[nv0] = tb_dau2dedx;
			mTrackEvent.dau2nsigma[nv0] = tb_dau2nsigma;
			mTrackEvent.dau2pt[nv0] = tb_dau2pt;
			mTrackEvent.dau2px[nv0] = tb_dau2px;
			mTrackEvent.dau2py[nv0] = tb_dau2py;
			mTrackEvent.dau2pz[nv0] = tb_dau2pz;
		//	mTrackEvent.dau2tpc[nv0] = tb_dau2tpc;
		//	mTrackEvent.dau2mass[nv0] = tb_dau2mass;
		//	mTrackEvent.dau2beta[nv0] = tb_dau2beta;
		
			mTrackEvent.dau3id[nv0] = tb_dau3id;
			mTrackEvent.dau3dca[nv0] = tb_dau3dca;
			mTrackEvent.dau3nhits[nv0] = tb_dau3nhits;
			mTrackEvent.dau3nhitsfit[nv0] = tb_dau3nhitsfit;
			mTrackEvent.dau3nhitsposs[nv0] = tb_dau3nhitsposs;
			mTrackEvent.dau3nhitsdedx[nv0] = tb_dau3nhitsdedx;
			mTrackEvent.dau3eta[nv0] = tb_dau3eta;
			mTrackEvent.dau3dedx[nv0] = tb_dau3dedx;
			mTrackEvent.dau3nsigma[nv0] = tb_dau3nsigma;
			mTrackEvent.dau3pt[nv0] = tb_dau3pt;
			mTrackEvent.dau3px[nv0] = tb_dau3px;
			mTrackEvent.dau3py[nv0] = tb_dau3py;
			mTrackEvent.dau3pz[nv0] = tb_dau3pz;
//			mTrackEvent.dau3tpc[nv0] = tb_dau3tpc;
//			mTrackEvent.dau3mass[nv0] = tb_dau3mass;
//			mTrackEvent.dau3beta[nv0] = tb_dau3beta;

			nv0++;
//*************************************************************************************************
		}
	}
	tb_nv0 = nv0;
	mTrackEvent.nv0 = tb_nv0;

	cout << "Track variables filled" << endl;

	LOG_DEBUG<<"filled track object"<<endm;
	trackTree->Fill();

//	mDauDcaVec1.clear();
//	mDauDcaVec2.clear();
//	mDauDcaVec3.clear();
	mDauVec1.clear();
	mDauVec2.clear();
	mDauVec3.clear();
//	mDauMass1.clear();
//	mDauMass2.clear();
//	mDauMass3.clear();
//	mDauBeta1.clear();
//	mDauBeta2.clear();
//	mDauBeta3.clear();

	return kStOK;
}
