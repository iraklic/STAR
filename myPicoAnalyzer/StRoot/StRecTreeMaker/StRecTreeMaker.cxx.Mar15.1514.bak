//Modified from StMiniMcMaker.cxx
///////////////////////////////////////////////////////////
#include "StMuDSTMaker/COMMON/StMuDstMaker.h"
#include "StMuDSTMaker/COMMON/StMuEvent.h"
#include "StMuDSTMaker/COMMON/StMuDst.h"
#include "StMuDSTMaker/COMMON/StMuTrack.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcTrack.h"

#include "StRecTreeMaker.h"
#include "StEventTypes.h"
#include "StEvent.h"
#include "StParticleTable.hh"
#include "StParticleDefinition.hh"
#include "TNtuple.h"
#include "TFile.h"
#include "TTree.h"
#include "TBranch.h"
#include "TMath.h"

#include "StMcEventMaker/StMcEventMaker.h"
#include "StMcEventTypes.hh"
#include "StMcEvent.hh"
#include "StMcEvent/StMcTrack.hh"
#include "StMcEvent/StMcTpcHitCollection.hh"
#include "StMcEvent/StMcTpcHit.hh"
#include "StMcEvent/StMcEmcHitCollection.hh"
#include "StMcEvent/StMcCalorimeterHit.hh"
#include "StMcEvent/StMcTofHitCollection.hh"
#include "StMcEvent/StMcTofHit.hh"
#include "StEvent/StTpcHitCollection.h"
#include "StEvent/StTpcHit.h"
#include "StEvent/StTrackPidTraits.h"
#include "StEvent/StDedxPidTraits.h"
#include "StEventUtilities/StuRefMult.hh"
#include "StBFChain.h"
#include "StMessMgr.h"

#include "StChain.h"
#include "St_DataSet.h"
#include "St_DataSetIter.h"
#include "StEventTypes.h"
#include "StTpcDedxPidAlgorithm.h"
#include "StParticleDefinition.hh"
#include "StPhysicalHelix.hh"
/*
#include "StStrangeMuDstMaker/StStrangeMuDstMaker.h"
#include "StStrangeMuDstMaker/StStrangeEvMuDst.hh"
#include "StStrangeMuDstMaker/StV0MuDst.hh"
#include "StStrangeMuDstMaker/StV0Mc.hh"
#include "StStrangeMuDstMaker/StXiMuDst.hh"
#include "StStrangeMuDstMaker/StXiMc.hh"
#include "StStrangeMuDstMaker/StKinkMuDst.hh"
#include "StStrangeMuDstMaker/StKinkMc.hh"
*/

#include "RecTree.h"

ClassImp(StRecTreeMaker)	// this a macro, no ";" here

StRecTreeMaker::StRecTreeMaker(StMuDstMaker* maker, const Char_t *outname="") : 
	mTupFile(0),
	trackTree(0)
{
	mMuDstMaker = maker;
	outName = outname;

	return;
}

StRecTreeMaker::~StRecTreeMaker() { return; }

Int_t StRecTreeMaker::Init()
{
	outName.ReplaceAll("root","rectree.root");
	mTupFile = new TFile(outName, "RECREATE");
	mTupFile->SetCompressionLevel(9);
	trackTree= new TTree("mTrackEvent","trackTree");
	trackTree->SetAutoSave(1000000);

	cout << "Initialize the recotree ... " << endl;

	trackTree->Branch("mIEvt",&mTrackEvent.mIEvt,"mIEvt/I");
	trackTree->Branch("OriginMult",&mTrackEvent.OriginMult,"OriginMult/I");
	trackTree->Branch("McMult",&mTrackEvent.McMult,"McMult/I");
	trackTree->Branch("mRcVertexX",&mTrackEvent.mRcVertexX,"mRcVertexX/F");
	trackTree->Branch("mRcVertexY",&mTrackEvent.mRcVertexY,"mRcVertexY/F");
	trackTree->Branch("mRcVertexZ",&mTrackEvent.mRcVertexZ,"mRcVertexZ/F");
	trackTree->Branch("mMcVertexX",&mTrackEvent.mMcVertexX,"mMcVertexX/F");
	trackTree->Branch("mMcVertexY",&mTrackEvent.mMcVertexY,"mMcVertexY/F");
	trackTree->Branch("mMcVertexZ",&mTrackEvent.mMcVertexZ,"mMcVertexZ/F");
	trackTree->Branch("MagField",&mTrackEvent.MagField,"MagField/F");

	trackTree->Branch("mNMcTrk",&mTrackEvent.mNMcTrk,"mNMcTrk/I");
	trackTree->Branch("mMcId",mTrackEvent.mMcId,"mMcId[mNMcTrk]/I");
	trackTree->Branch("mGeantId",mTrackEvent.mGeantId,"mGeantId[mNMcTrk]/I");
	trackTree->Branch("mMcPt",mTrackEvent.mMcPt,"mMcPt[mNMcTrk]/F");
	trackTree->Branch("mMcPz",mTrackEvent.mMcPz,"mMcPz[mNMcTrk]/F");
	trackTree->Branch("mMcEta",mTrackEvent.mMcEta,"mMcEta[mNMcTrk]/F");
	trackTree->Branch("mMcPhi",mTrackEvent.mMcPhi,"mMcPhi[mNMcTrk]/F");
	trackTree->Branch("mMcStartX",mTrackEvent.mMcStartX,"mMcStartX[mNMcTrk]/F");
	trackTree->Branch("mMcStartY",mTrackEvent.mMcStartY,"mMcStartY[mNMcTrk]/F");
	trackTree->Branch("mMcStartZ",mTrackEvent.mMcStartZ,"mMcStartZ[mNMcTrk]/F");
	trackTree->Branch("mMcNTpchits",mTrackEvent.mMcNTpchits,"mMcNTpchits[mNMcTrk]/I");
	trackTree->Branch("mMcNTofhits",mTrackEvent.mMcNTofhits,"mMcNTofhits[mNMcTrk]/I");
	trackTree->Branch("mMcNBemchits",mTrackEvent.mMcNBemchits,"mMcNBemchits[mNMcTrk]/I");
	trackTree->Branch("mMcNEemchits",mTrackEvent.mMcNEemchits,"mMcNEemchits[mNMcTrk]/I");
	trackTree->Branch("mMcNFpdhits",mTrackEvent.mMcNFpdhits,"mMcNFpdhits[mNMcTrk]/I");
	trackTree->Branch("mMcBemcHitSumE",mTrackEvent.mMcBemcHitSumE,"mMcBemcHitSumE[mNMcTrk]/F");
	trackTree->Branch("mMcEemcHitSumE",mTrackEvent.mMcEemcHitSumE,"mMcEemcHitSumE[mNMcTrk]/F");
	trackTree->Branch("mMcFpdHitSumE",mTrackEvent.mMcFpdHitSumE,"mMcFpdHitSumE[mNMcTrk]/F");

	trackTree->Branch("mNRcTrk",&mTrackEvent.mNRcTrk,"mNRcTrk/I");
	trackTree->Branch("mRcId",mTrackEvent.mRcId,"mRcId[mNRcTrk]/I");
	trackTree->Branch("mRcAssoId",mTrackEvent.mRcAssoId,"mRcAssoId[mNRcTrk]/I");
	trackTree->Branch("mRcAssoGId",mTrackEvent.mRcAssoGId,"mRcAssoGId[mNRcTrk]/I");
	trackTree->Branch("mRcPt",mTrackEvent.mRcPt,"mRcPt[mNRcTrk]/F");
	trackTree->Branch("mRcPz",mTrackEvent.mRcPz,"mRcPz[mNRcTrk]/F");
	trackTree->Branch("mRcEta",mTrackEvent.mRcEta,"mRcEta[mNRcTrk]/F");
	trackTree->Branch("mRcPhi",mTrackEvent.mRcPhi,"mRcPhi[mNRcTrk]/F");
	trackTree->Branch("mRcNhits",mTrackEvent.mRcNhits,"mRcNhits[mNRcTrk]/I");
	trackTree->Branch("mRcNhitsFit",mTrackEvent.mRcNhitsFit,"mRcNhitsFit[mNRcTrk]/I");
	trackTree->Branch("mRcNhitsPoss",mTrackEvent.mRcNhitsPoss,"mRcNhitsPoss[mNRcTrk]/I");
	trackTree->Branch("mRcLength",mTrackEvent.mRcLength,"mRcLength[mNRcTrk]/F");
	trackTree->Branch("mRcLengthMeasured",mTrackEvent.mRcLengthMeasured,"mRcLengthMeasured[mNRcTrk]/F");
	trackTree->Branch("mRcdEdxLength",mTrackEvent.mRcdEdxLength,"mRcdEdxLength[mNRcTrk]/F");
	trackTree->Branch("mRcDedx",mTrackEvent.mRcDedx,"mRcDedx[mNRcTrk]/F");
	trackTree->Branch("mRcNDedxPts",mTrackEvent.mRcNDedxPts,"mRcNDedxPts[mNRcTrk]/I");

	trackTree->Branch("mRcnSigmaElectron",mTrackEvent.mRcnSigmaElectron,"mRcnSigmaElectron[mNRcTrk]/F");
	trackTree->Branch("mRcnSigmaPion",mTrackEvent.mRcnSigmaPion,"mRcnSigmaPion[mNRcTrk]/F");
	trackTree->Branch("mRcnSigmaKaon",mTrackEvent.mRcnSigmaKaon,"mRcnSigmaKaon[mNRcTrk]/F");
	trackTree->Branch("mRcnSigmaProton",mTrackEvent.mRcnSigmaProton,"mRcnSigmaProton[mNRcTrk]/F");

	trackTree->Branch("mHelixCurv",mTrackEvent.mHelixCurv,"mHelixCurv[mNRcTrk]/F");
	trackTree->Branch("mHelixDip",mTrackEvent.mHelixDip,"mHelixDip[mNRcTrk]/F");
	trackTree->Branch("mHelixPhase",mTrackEvent.mHelixPhase,"mHelixPhase[mNRcTrk]/F");
	trackTree->Branch("mHelixX",mTrackEvent.mHelixX,"mHelixX[mNRcTrk]/F");
	trackTree->Branch("mHelixY",mTrackEvent.mHelixY,"mHelixY[mNRcTrk]/F");
	trackTree->Branch("mHelixZ",mTrackEvent.mHelixZ,"mHelixZ[mNRcTrk]/F");
	trackTree->Branch("mCharge",mTrackEvent.mCharge,"mCharge[mNRcTrk]/I");

	trackTree->Branch("mOuterHelixCurv",mTrackEvent.mOuterHelixCurv,"mOuterHelixCurv[mNRcTrk]/F");
	trackTree->Branch("mOuterHelixDip",mTrackEvent.mOuterHelixDip,"mOuterHelixDip[mNRcTrk]/F");
	trackTree->Branch("mOuterHelixPhase",mTrackEvent.mOuterHelixPhase,"mOuterHelixPhase[mNRcTrk]/F");
	trackTree->Branch("mOuterHelixX",mTrackEvent.mOuterHelixX,"mOuterHelixX[mNRcTrk]/F");
	trackTree->Branch("mOuterHelixY",mTrackEvent.mOuterHelixY,"mOuterHelixY[mNRcTrk]/F");
	trackTree->Branch("mOuterHelixZ",mTrackEvent.mOuterHelixZ,"mOuterHelixZ[mNRcTrk]/F");
	trackTree->Branch("mOuterCharge",mTrackEvent.mOuterCharge,"mOuterCharge[mNRcTrk]/I");

	trackTree->Branch("sharedTpcHits",mTrackEvent.sharedTpcHits,"sharedTpcHits[mNRcTrk]/I");

//*************************************************************************************************
	trackTree->Branch("nv0",&mV0Dst.nv0,"nv0/I");
//	trackTree->Branch("ndau1",&mV0Dst.ndau1,"ndau1/I");
	trackTree->Branch("ndau2",&mV0Dst.ndau2,"ndau2/I");
	trackTree->Branch("ndau3",&mV0Dst.ndau3,"ndau3/I");
	
	trackTree->Branch("v0mass",mV0Dst.v0mass,"v0mass[nv0]/F");
	trackTree->Branch("v0pt",mV0Dst.v0pt,"v0pt[nv0]/F");
	trackTree->Branch("v0rapidity",mV0Dst.v0rapidity,"v0rapidity[nv0]/F");
	trackTree->Branch("v0eta",mV0Dst.v0eta,"v0eta[nv0]/F");
	trackTree->Branch("v0x",mV0Dst.v0x,"v0x[nv0]/F");
	trackTree->Branch("v0y",mV0Dst.v0y,"v0y[nv0]/F");
	trackTree->Branch("v0z",mV0Dst.v0z,"v0z[nv0]/F");
	trackTree->Branch("v0px",mV0Dst.v0px,"v0px[nv0]/F");
	trackTree->Branch("v0py",mV0Dst.v0py,"v0py[nv0]/F");
	trackTree->Branch("v0pz",mV0Dst.v0pz,"v0pz[nv0]/F");
	trackTree->Branch("v0declen",mV0Dst.v0declen,"v0declen[nv0]/F");
	trackTree->Branch("v0dca",mV0Dst.v0dca,"v0dca[nv0]/F");
//	trackTree->Branch("dca1to2",mV0Dst.dca1to2,"dca1to2[nv0]/F");
//	trackTree->Branch("dca1to3",mV0Dst.dca1to3,"dca1to3[nv0]/F");
	trackTree->Branch("dca2to3",mV0Dst.dca2to3,"dca2to3[nv0]/F");
//	trackTree->Branch("dca1toxv0123",mV0Dst.dca1toxv0123,"dca1toxv0123[nv0]/F");
//	trackTree->Branch("dca2toxv0123",mV0Dst.dca2toxv0123,"dca2toxv0123[nv0]/F");
//	trackTree->Branch("dca3toxv0123",mV0Dst.dca3toxv0123,"dca3toxv0123[nv0]/F");
//*****
//	trackTree->Branch("dca1toxv012",mV0Dst.dca1toxv012,"dca1toxv012[nv0]/F");
//	trackTree->Branch("dca2toxv012",mV0Dst.dca2toxv012,"dca2toxv012[nv0]/F");
	trackTree->Branch("dca2toxv023",mV0Dst.dca2toxv023,"dca2toxv023[nv0]/F");
	trackTree->Branch("dca3toxv023",mV0Dst.dca3toxv023,"dca3toxv023[nv0]/F");
//	trackTree->Branch("dca1toxv013",mV0Dst.dca1toxv013,"dca1toxv013[nv0]/F");
//	trackTree->Branch("dca3toxv013",mV0Dst.dca3toxv013,"dca3toxv013[nv0]/F");
//	trackTree->Branch("xv012toPV",mV0Dst.xv012toPV,"xv012toPV[nv0]/F");
	trackTree->Branch("xv023toPV",mV0Dst.xv023toPV,"xv023toPV[nv0]/F");
//	trackTree->Branch("xv013toPV",mV0Dst.xv013toPV,"xv013toPV[nv0]/F");
//	trackTree->Branch("dcaxv012toPV",mV0Dst.dcaxv012toPV,"dcaxv012toPV[nv0]/F");
	trackTree->Branch("dcaxv023toPV",mV0Dst.dcaxv023toPV,"dcaxv023toPV[nv0]/F");
//	trackTree->Branch("dcaxv013toPV",mV0Dst.dcaxv013toPV,"dcaxv013toPV[nv0]/F");
/*
	trackTree->Branch("dau1id",mV0Dst.dau1id,"dau1id[nv0]/I");
	trackTree->Branch("dau1dca",mV0Dst.dau1dca,"dau1dca[nv0]/F");
	trackTree->Branch("dau1nhits",mV0Dst.dau1nhits,"dau1nhits[nv0]/I");
	trackTree->Branch("dau1nhitsfit",mV0Dst.dau1nhitsfit,"dau1nhitsfit[nv0]/I");
	trackTree->Branch("dau1nhitsposs",mV0Dst.dau1nhitsposs,"dau1nhitsposs[nv0]/I");
	trackTree->Branch("dau1nhitsdedx",mV0Dst.dau1nhitsdedx,"dau1nhitsdedx[nv0]/I");
	trackTree->Branch("dau1eta",mV0Dst.dau1eta,"dau1eta[nv0]/F");
	trackTree->Branch("dau1dedx",mV0Dst.dau1dedx,"dau1dedx[nv0]/F");
	trackTree->Branch("dau1Z",mV0Dst.dau1Z,"dau1Z[nv0]/F");
	trackTree->Branch("dau1nsigma",mV0Dst.dau1nsigma,"dau1nsigma[nv0]/F");
	trackTree->Branch("dau1pt",mV0Dst.dau1pt,"dau1pt[nv0]/F");
	trackTree->Branch("dau1px",mV0Dst.dau1px,"dau1px[nv0]/F");
	trackTree->Branch("dau1py",mV0Dst.dau1py,"dau1py[nv0]/F");
	trackTree->Branch("dau1pz",mV0Dst.dau1pz,"dau1pz[nv0]/F");
	trackTree->Branch("dau1tpc",mV0Dst.dau1tpc,"dau1tpc[nv0]/I");
	trackTree->Branch("dau1mass",mV0Dst.dau1mass,"dau1mass[nv0]/F"); // xuyifei_Feb13
	trackTree->Branch("dau1beta",mV0Dst.dau1beta,"dau1beta[nv0]/F"); // xuyifei_Feb13
*/
	trackTree->Branch("dau2id",mV0Dst.dau2id,"dau2id[nv0]/I");
	trackTree->Branch("dau2dca",mV0Dst.dau2dca,"dau2dca[nv0]/F");
	trackTree->Branch("dau2nhits",mV0Dst.dau2nhits,"dau2nhits[nv0]/I");
	trackTree->Branch("dau2nhitsfit",mV0Dst.dau2nhitsfit,"dau2nhitsfit[nv0]/I");
	trackTree->Branch("dau2nhitsposs",mV0Dst.dau2nhitsposs,"dau2nhitsposs[nv0]/I");
	trackTree->Branch("dau2nhitsdedx",mV0Dst.dau2nhitsdedx,"dau2nhitsdedx[nv0]/I");
	trackTree->Branch("dau2eta",mV0Dst.dau2eta,"dau2eta[nv0]/F");
	trackTree->Branch("dau2dedx",mV0Dst.dau2dedx,"dau2dedx[nv0]/F");
	trackTree->Branch("dau2nsigma",mV0Dst.dau2nsigma,"dau2nsigma[nv0]/F");
	trackTree->Branch("dau2pt",mV0Dst.dau2pt,"dau2pt[nv0]/F");
	trackTree->Branch("dau2px",mV0Dst.dau2px,"dau2px[nv0]/F");
	trackTree->Branch("dau2py",mV0Dst.dau2py,"dau2py[nv0]/F");
	trackTree->Branch("dau2pz",mV0Dst.dau2pz,"dau2pz[nv0]/F");
//	trackTree->Branch("dau2tpc",mV0Dst.dau2tpc,"dau2tpc[nv0]/I");
//	trackTree->Branch("dau2mass",mV0Dst.dau2mass,"dau2mass[nv0]/F"); // xuyifei_Feb13
//	trackTree->Branch("dau2beta",mV0Dst.dau2beta,"dau2beta[nv0]/F"); // xuyifei_Feb13

	trackTree->Branch("dau3id",mV0Dst.dau3id,"dau3id[nv0]/I");
	trackTree->Branch("dau3dca",mV0Dst.dau3dca,"dau3dca[nv0]/F");
	trackTree->Branch("dau3nhits",mV0Dst.dau3nhits,"dau3nhits[nv0]/I");
	trackTree->Branch("dau3nhitsfit",mV0Dst.dau3nhitsfit,"dau3nhitsfit[nv0]/I");
	trackTree->Branch("dau3nhitsposs",mV0Dst.dau3nhitsposs,"dau3nhitsposs[nv0]/I");
	trackTree->Branch("dau3nhitsdedx",mV0Dst.dau3nhitsdedx,"dau3nhitsdedx[nv0]/I");
	trackTree->Branch("dau3eta",mV0Dst.dau3eta,"dau3eta[nv0]/F");
	trackTree->Branch("dau3dedx",mV0Dst.dau3dedx,"dau3dedx[nv0]/F");
	trackTree->Branch("dau3nsigma",mV0Dst.dau3nsigma,"dau3nsigma[nv0]/F");
	trackTree->Branch("dau3pt",mV0Dst.dau3pt,"dau3pt[nv0]/F");
	trackTree->Branch("dau3px",mV0Dst.dau3px,"dau3px[nv0]/F");
	trackTree->Branch("dau3py",mV0Dst.dau3py,"dau3py[nv0]/F");
	trackTree->Branch("dau3pz",mV0Dst.dau3pz,"dau3pz[nv0]/F");
//	trackTree->Branch("dau3tpc",mV0Dst.dau3tpc,"dau3tpc[nv0]/I");
//	trackTree->Branch("dau3mass",mV0Dst.dau3mass,"dau3mass[nv0]/F"); // xuyifei_Feb13
//	trackTree->Branch("dau3beta",mV0Dst.dau3beta,"dau3beta[nv0]/F"); // xuyifei_Feb13

//*************************************************************************************************
	mDauVec1.clear();// StMuTrack*
	mDauVec2.clear();
	mDauVec3.clear();

	mDauDcaVec1.clear();// Double
	mDauDcaVec2.clear();
	mDauDcaVec3.clear();
	mDauMass1.clear();
	mDauMass2.clear();
	mDauMass3.clear();
	mDauBeta1.clear();
	mDauBeta2.clear();
	mDauBeta3.clear();
//*************************************************************************************************

	return StMaker::Init();
}

void StRecTreeMaker::Clear(Option_t *opt)
{
	StMaker::Clear();
}

Int_t StRecTreeMaker::Finish()
{

	mTupFile->Write();
	mTupFile->Close();

	return kStOK;
}

Int_t StRecTreeMaker::Make()
{
	mu = mMuDstMaker->muDst();

	StMuEvent *pMuEvent=mu->event();
	if(!mu || !pMuEvent ) return kStOK;
	
	//event info
	mTrackEvent.mIEvt = mu->event()->eventId();

	TClonesArray *PrimaryVertices = mu->primaryVertices();
	Int_t NoPrimaryVertices = PrimaryVertices->GetEntriesFast();
	TClonesArray *GlobalTracks = mu->array(muGlobal);
	Int_t NoGlobalTracks = GlobalTracks->GetEntriesFast(); 
	TClonesArray *MuMcVertices = mu->mcArray(0);
	Int_t NoMuMcVertices = MuMcVertices->GetEntriesFast();
	TClonesArray *MuMcTracks = mu->mcArray(1);
	Int_t NoMuMcTracks = MuMcTracks->GetEntriesFast(); 
	
//*******************************************************************
//*******************************************************************

	if (! NoMuMcVertices || ! NoMuMcTracks)
	{
		cout << "Event has no MC information ==> skip it" << endl;
		return kStOK;
	}

	mTrackEvent.MagField = mu->event()->magneticField()/10.;

	Int_t nVtx = 0;
	if(NoPrimaryVertices!=(int)mu->numberOfPrimaryVertices())
	{
		cout << "No. of Primary Vertices inconsistent! " << endl;
	}
	cout << "Found " << NoPrimaryVertices << " Primary Vertices ! " << endl;

	for(int i = 0; i < (int)(mu->numberOfPrimaryVertices()); i++)
	{
		StMuPrimaryVertex *pVtx = mu->primaryVertex(i);
		if(!pVtx)
		{
			cout << "no vertex pointer! " << endl;
			continue;
		}
		if(!pVtx->idTruth() || pVtx->idTruth()<0 || pVtx->idTruth()>NoMuMcVertices)
		{
			cout << "Illegal idTruth " << pVtx->idTruth() << " The vertex is ignored" << endl;
			continue;
		}
		StMuMcVertex *mcVertex = (StMuMcVertex *) MuMcVertices->UncheckedAt(pVtx->idTruth()-1);
		if(mcVertex->Id() != pVtx->idTruth())
		{
			cout << "Mismatched idTruth " << pVtx->idTruth() << " and mcVertex Id " <<mcVertex->Id() << " The vertex is ignored" <<endl;
			continue;
		}
		StThreeVectorF mVertexPosition = pVtx->position();
		mTrackEvent.mRcVertexX = mVertexPosition.x(); 
		mTrackEvent.mRcVertexY = mVertexPosition.y(); 
		mTrackEvent.mRcVertexZ = mVertexPosition.z();
		mTrackEvent.OriginMult = mu->event()->refMult();
		mTrackEvent.mMcVertexX = mcVertex->XyzV().x(); 
		mTrackEvent.mMcVertexY = mcVertex->XyzV().y(); 
		mTrackEvent.mMcVertexZ = mcVertex->XyzV().z();
		mTrackEvent.McMult = mcVertex->NoDaughters();

		nVtx++; break;
	}

	if (nVtx<=0)
	{
		cout << "Event has no valid Vertex info. ==> skip it" << endl;
		mTrackEvent.mRcVertexX = -999.; 
		mTrackEvent.mRcVertexY = -999.; 
		mTrackEvent.mRcVertexZ = -999.;
		mTrackEvent.OriginMult = mu->event()->refMult();
		StMuMcVertex *mcVertex = (StMuMcVertex *) MuMcVertices->UncheckedAt(0);
		if(!mcVertex)
		{
			mTrackEvent.mMcVertexX = -999.; 
			mTrackEvent.mMcVertexY = -999.; 
			mTrackEvent.mMcVertexZ = -999.;
			mTrackEvent.McMult = 0;
		}
		else
		{
			mTrackEvent.mMcVertexX = mcVertex->XyzV().x(); 
			mTrackEvent.mMcVertexY = mcVertex->XyzV().y(); 
			mTrackEvent.mMcVertexZ = mcVertex->XyzV().z();
			mTrackEvent.McMult = mcVertex->NoDaughters();
		}
		return kStOK;
	}

	StThreeVectorF pv = pMuEvent->primaryVertexPosition();
	pv.setX(mVertexPosition.x());
	pv.setY(mVertexPosition.y());
	pv.setZ(mVertexPosition.z());

	cout << "Event variables filled" << endl;
	//track level

	Int_t imc = 0;
	for(Int_t m = 0; m < NoMuMcTracks; m++)
	{
		StMuMcTrack *mcTrack = (StMuMcTrack *) MuMcTracks->UncheckedAt(m);
		if(! mcTrack) continue;
		mTrackEvent.mMcId[imc] = mcTrack->Id();
		mTrackEvent.mGeantId[imc] = mcTrack->GePid();
	
		mTrackEvent.mMcPt[imc] = mcTrack->Pxyz().perp();
		mTrackEvent.mMcPz[imc] = mcTrack->Pxyz().z();
		mTrackEvent.mMcEta[imc] = mcTrack->Pxyz().pseudoRapidity();
		mTrackEvent.mMcPhi[imc] = mcTrack->Pxyz().phi();
		Int_t IdVx = mcTrack->IdVx();
		if (IdVx == 1) // primary
		{
			mTrackEvent.mMcStartX[imc] = mTrackEvent.mMcVertexX;
			mTrackEvent.mMcStartY[imc] = mTrackEvent.mMcVertexY;
			mTrackEvent.mMcStartZ[imc] = mTrackEvent.mMcVertexZ;
		}
		else
		{
			mTrackEvent.mMcStartX[imc] = -999.;
			mTrackEvent.mMcStartY[imc] = -999.;
			mTrackEvent.mMcStartZ[imc] = -999.;
		}

		mTrackEvent.mMcNTpchits[imc] = mcTrack->No_tpc_hit();
		mTrackEvent.mMcNTofhits[imc] = mcTrack->No_tof_hit();
		mTrackEvent.mMcNBemchits[imc] = mcTrack->No_emc_hit();
		mTrackEvent.mMcNEemchits[imc] = mcTrack->No_eem_hit();
		mTrackEvent.mMcNFpdhits[imc] = mcTrack->No_fpd_hit();

		mTrackEvent.mMcBemcHitSumE[imc] = 0.;
		mTrackEvent.mMcEemcHitSumE[imc] = 0.;
		mTrackEvent.mMcFpdHitSumE[imc] = 0.;
	
		imc++;
	}
	mTrackEvent.mNMcTrk = imc;

	int irc = 0;
	if(NoGlobalTracks!=(int)mu->numberOfGlobalTracks())
	{
		cout << "No. of global tracks inconsistent! " << endl;
	}
	for(int i = 0; i<(int)mu->numberOfGlobalTracks(); i++)
	{
		StMuTrack *gTrack = mu->globalTracks(i);

		if(!gTrack) continue;
		if(gTrack->flag()<=0 || gTrack->flag()>=1000) continue;
		int nHitsFit = gTrack->nHitsFit(); // remove kTpcId;
//		if(nHitsFit<5) continue;
		float ratio = (1.0*nHitsFit)/(1.0*gTrack->nHitsPoss()); //remove kTpcId;
//		if(ratio<0.1) continue;

		if(gTrack->idTruth() <= 0 || gTrack->idTruth() > NoMuMcTracks)
		{
			cout << "Illegal idTruth " << gTrack->idTruth() << " The track is ignored" << endl;
			continue;
		}
		StMuMcTrack *mcTrack = (StMuMcTrack *) MuMcTracks->UncheckedAt(gTrack->idTruth()-1);
		if (mcTrack->Id() != gTrack->idTruth())
		{
			cout << "Mismatched idTruth " << gTrack->idTruth() << " and mcTrack Id " <<mcTrack->Id() << " The track is ignored" <<endl;
			continue;
		}
		else
		{
			mTrackEvent.mRcAssoId[irc] = mcTrack->Id();
			mTrackEvent.mRcAssoGId[irc] = mcTrack->GePid();//bug fixed, it was [imc]
		}

//*************************************************************************************************
		int track_id = 0;
		double track_dca = 0;
		int track_nhits = 0;
		int track_nhitsfit = 0;
		int track_nhitsposs = 0;
		int track_nhitsdedx = 0;
		double track_eta = 0;
		double track_dedx = 0;
		double track_nsigma_proton = 0;
		double track_nsigma_pion = 0;
		double track_pt = 0;
		double track_px = 0;
		double track_py = 0;
		double track_pz = 0;
//		int track_tpc = 0;
//		double track_mass = 0;
//		double track_beta = 0;

		track_id = gTrack->id();
		track_charge = gTrack->charge();
		track_nhits = gTrack->nHits();
		track_nhitsfit = gTrack->nHitsFit();
		track_nhitsposs = gTrack->nHitsPoss();
		track_nhitsdedx = gTrack->nHitsDedx();
		track_eta = gTrack->eta();
		track_dedx = gTrack->dEdx();
		track_pt = gTrack->pt();
		track_px = gTrack->p().x();
		track_py = gTrack->p().y();
		track_pz = gTrack->p().z();
		track_nsigma_proton = gTrack->nSigmaProton();
		track_nsigma_pion = gTrack->nSigmaPion();

		if(track_nhitsfit < 15) continue;
		if(track_nhitsdedx< 15) continue;
		if(fabs(track_charge) != 1) continue;
		if(fabs(track_eta) > 1.0) continue;
		if(double(track_nhitsfit)/double(track_nhitsposs)<0.52) continue;
		if(track_pt<0.15) continue;
//*************************************************************************************************

		mTrackEvent.mRcId[irc] = gTrack->id();
		mTrackEvent.mRcPt[irc] = gTrack->pt();
		mTrackEvent.mRcPz[irc] = gTrack->p().z();
		mTrackEvent.mRcEta[irc] = gTrack->eta();
		mTrackEvent.mRcPhi[irc] = gTrack->phi();
		mTrackEvent.mRcNhits[irc] = gTrack->nHits();
		mTrackEvent.mRcNhitsFit[irc] = gTrack->nHitsFit();
		mTrackEvent.mRcNhitsPoss[irc] = gTrack->nHitsPoss();
		mTrackEvent.mRcLength[irc] = gTrack->length();
		mTrackEvent.mRcLengthMeasured[irc] = gTrack->lengthMeasured();
		mTrackEvent.mRcdEdxLength[irc] = gTrack->probPidTraits().dEdxTrackLength();
		mTrackEvent.mRcDedx[irc] = gTrack->dEdx();
		mTrackEvent.mRcNDedxPts[irc] = gTrack->nHitsDedx();

		mTrackEvent.mRcnSigmaElectron[irc] = gTrack->nSigmaElectron();
		mTrackEvent.mRcnSigmaPion[irc] = gTrack->nSigmaPion();
		mTrackEvent.mRcnSigmaKaon[irc] = gTrack->nSigmaKaon();
		mTrackEvent.mRcnSigmaProton[irc] = gTrack->nSigmaProton();

		mTrackEvent.sharedTpcHits[irc] = -1;

		StMuTrack *pTrack = const_cast<StMuTrack *>(gTrack->primaryTrack());
		if(pTrack)
		{
			mTrackEvent.mRcPt[irc] = pTrack->pt();
			mTrackEvent.mRcPz[irc] = pTrack->p().z();
			mTrackEvent.mRcEta[irc] = pTrack->eta();
			mTrackEvent.mRcPhi[irc] = pTrack->phi();
			mTrackEvent.mRcNhits[irc] = pTrack->nHits();

			mTrackEvent.mRcNhitsFit[irc] = pTrack->nHitsFit();
			mTrackEvent.mRcNhitsPoss[irc] = pTrack->nHitsPoss();
			mTrackEvent.mRcLength[irc] = pTrack->length();
			mTrackEvent.mRcLengthMeasured[irc] = pTrack->lengthMeasured();

			mTrackEvent.mRcdEdxLength[irc] = pTrack->probPidTraits().dEdxTrackLength();
			mTrackEvent.mRcDedx[irc] = pTrack->dEdx();
			mTrackEvent.mRcNDedxPts[irc] = pTrack->nHitsDedx();

			mTrackEvent.sharedTpcHits[irc] = 1;
		}
	
		StPhysicalHelixD ghelix = gTrack->helix();
		StPhysicalHelixD helix = gTrack->outerHelix();

		mTrackEvent.mHelixCurv[irc] = ghelix.curvature();
		mTrackEvent.mHelixDip[irc]= ghelix.dipAngle();
		mTrackEvent.mHelixPhase[irc]= ghelix.phase();
		mTrackEvent.mHelixX[irc]= ghelix.origin().x();
		mTrackEvent.mHelixY[irc]= ghelix.origin().y();
		mTrackEvent.mHelixZ[irc]= ghelix.origin().z();
		mTrackEvent.mCharge[irc]= gTrack->charge();
		mTrackEvent.mOuterHelixCurv[irc] = helix.curvature();
		mTrackEvent.mOuterHelixDip[irc]= helix.dipAngle();
		mTrackEvent.mOuterHelixPhase[irc]= helix.phase();
		mTrackEvent.mOuterHelixX[irc]= helix.origin().x();
		mTrackEvent.mOuterHelixY[irc]= helix.origin().y();
		mTrackEvent.mOuterHelixZ[irc]= helix.origin().z();
		mTrackEvent.mOuterCharge[irc]= gTrack->charge();

		irc++;
//*************************************************************************************************
		if(track_nsigma_proton >= -2 && track_nsiamg_proton <= 2)
		{
			mDauVec2.push_back(gtrack);
		}
		if(track_nsigma_pion >= -2 && track_nsiamg_pion <= 2)
		{
			mDauVec3.push_back(gtrack);
		}
//*************************************************************************************************
	}
//*************************************************************************************************
	if(mDauVec2.size() != mDauVec3.size()) {cerr<<"mDauVec2.size != mDauVec3.size"<<endl;return 0;}
	for(int i = 0; i < mDauVec2.size(); i++)
	{
		StMuTrack * track2 = mDauVec2[i];
		StPhysicalHelixD helix2 = track2.helix();
		
	}
//*************************************************************************************************
	mTrackEvent.mNRcTrk = irc;

	cout << "Track variables filled" << endl;

	LOG_DEBUG<<"filled track object"<<endm;
	trackTree->Fill();

	mDauDcaVec1.clear();
	mDauDcaVec2.clear();
	mDauDcaVec3.clear();
	mDauVec1.clear();
	mDauVec2.clear();
	mDauVec3.clear();
	mDauMass1.clear();
	mDauMass2.clear();
	mDauMass3.clear();
	mDauBeta1.clear();
	mDauBeta2.clear();
	mDauBeta3.clear();

	return kStOK;
}
